---
options :
  # should getters / setters be prefixed with get / set?
  getSyntax: False
  # should POD members be exposed with getters/setters in classes that have them as members?
  exposePODMembers: False
  includeSubfolder: True

## right now we rigurously enforce:
##  - No breaking of PODness:
##        - No use of relations and vectors
##     - Use special Relation structures where needed, indexing by ID (index)
##        - IDs are stored as eic::Index, which is a thin layer of an signed integer
##          where -1 relates to "no index".
##        - For 1-to-many relations: Use many-to-1 IDs instead --> use forward links
##          This puts the burden on the reconstruction algorithm and keeps the data 2D!
##  - Use float most of the time except for 4-vectors where ppm precision is important.
##  - Data alignment: 
##        - data should be aligned with a 64-bit structure where possible.
##        - when using 32 bit values, use them in pairs (or after all 64-bit variables are defined). 
##        - same goes for 16-bit values (keep them aligned with the largest following component)
##  - Explicitly specify the integer length (use the typedefs from <cstdint>, 
##    such as int32_t etc)

components:

  ## simple numerical index, but with good automatic default values
  eic::Index:
    Members:
      - int32_t value
    ExtraCode:
      declaration: "
        Index() : value{-1} {}\n
        Index(int32_t idx) : value {idx} {}\n
        Index& operator=(int32_t idx) {value = idx; return *this;}\n
        operator int32_t() const {return value;}\n
        bool valid() const {return value >= 0;}\n
        bool empty() const {return value < 0;}\n
      "
  eic::CentralIndex:
    Members:
      - int32_t negative
      - int32_t barrel
      - int32_t positive
    ExtraCode:
      declaration: "
        CentralIndex() : negative{-1}, barrel{-1}, positive{-1} {}\n
        CentralIndex(int32_t n, int32_t b, int32_t p) : negative{n}, barrel{b}, positive{p} {}\n
        bool valid() const {return negative >= 0 || barrel >= 0 || positive >=0 ;}\n
        bool empty() const {return !valid();}\n
      "

  ## first-second pair of float s
  eic::FloatPair:
    Members:
      - float first
      - float second
    ExtraCode:
      includes: "#include <tuple>"
      declaration: "
        FloatPair() : first{0}, second{0} {}\n
        FloatPair(double  a, double  b) : first{static_cast<float>(a)}, second{static_cast<float>(b)} {}\n
        FloatPair(const std::pair<float, float>& p) : first{p.first}, second{p.second} {}\n
        FloatPair& operator=(const std::pair<float, float>& p) {first = p.first; second = p.second; return *this;}\n
        float& operator[](unsigned i) {return *(&first + i);}\n
        const float& operator[](unsigned i) const {return *(&first + i);}\n
        operator std::pair<float, float>() const {return {first, second};}\n
      "

  eic::VectorXY:
    Members:
      - float x          // [mm] or [GeV]
      - float y          //
    ExtraCode:
      includes: "#include <cmath>\n"
      declaration: "
        VectorXY() : x{0}, y{0} {}\n
        VectorXY(double xx, double yy) : x{static_cast<float>(xx)}, y{static_cast<float>(yy)} {}\n
        float& operator[](unsigned i) {return *(&x + i);}\n
        const float& operator[](unsigned i) const {return *(&x + i);}\n
        float mag() const {return std::hypot(x, y);}\n
        float r() const {return mag();}\n
        float phi() const {return atan2(y, x);}\n
        operator std::pair<float, float>() const {return {x, y};}\n
        float dot(const VectorXY& rhs) const {return x*rhs.x + y*rhs.y;}\n
        VectorXY add(const VectorXY& rhs) const {return {x+rhs.x, y+rhs.y};}\n
        VectorXY subtract(const VectorXY& rhs) const {return {x-rhs.x, y-rhs.y};}\n
        VectorXY scale(double f) const {return {f*x, f*y};}\n
      "

  eic::Direction:
    Members:
      - float theta      // [rad, 0->pi]
      - float phi        // [rad, -pi->pi]
    ExtraCode:
      includes: "#include <cmath>\n#include <tuple>"
      declaration: "
        Direction() : theta{0}, phi{0} {}\n
        Direction(double th, double ph) : theta{static_cast<float>(th)}, phi{static_cast<float>(ph)} {}\n
        Direction(double x, double y, double z)\n
          : theta{static_cast<float>(acos(z/std::hypot(x,y,z)))}\n
          , phi{static_cast<float>(atan2(y,x))} {}\n
        template <class VectorType> Direction(const VectorType& v) : Direction(v.theta(), v.phi()) {}\n
        operator std::pair<float, float>() const {return {theta, phi};}\n
        float eta() const {return -log(tan(0.5*theta));}\n
        Direction add(const Direction& rhs) const {return {theta+rhs.theta, phi+rhs.phi};}\n
        Direction subtract(const Direction& rhs) const {return {theta-rhs.theta, phi-rhs.phi};}\n
      "

  eic::VectorXYZ:
    Members:
      - float x          // [mm] or [GeV]
      - float y          //
      - float z          //
    ExtraCode:
      includes: "#include <cmath>\n#include<tuple>"
      declaration: "
        VectorXYZ() : x{0}, y{0}, z{0} {}\n
        VectorXYZ(double xx, double yy, double zz) : x{static_cast<float>(xx)}, y{static_cast<float>(yy)}, z{static_cast<float>(zz)} {}\n
        template<class VectorPolarType> VectorXYZ(const VectorPolarType& v) : VectorXYZ(v.x(), v.y(), v.z()) {}\n
        float& operator[](unsigned i) {return *(&x + i);}\n
        const float& operator[](unsigned i) const {return *(&x + i);}\n
        float mag() const {return std::hypot(x, y, z);}\n
        float r() const {return mag();}\n
        float theta() const {return acos(z/mag());}\n
        float phi() const {return atan2(y,x);}\n
        float eta() const {return -log(tan(0.5*theta()));}\n
        operator std::tuple<float, float, float>() {return {x, y, z};}\n
        float dot(const VectorXYZ& rhs) const {return x*rhs.x + y*rhs.y + z*rhs.z;}\n
        VectorXYZ add(const VectorXYZ& rhs) const {return {x+rhs.x, y+rhs.y, z+rhs.z};}\n
        VectorXYZ subtract(const VectorXYZ& rhs) const {return {x-rhs.x, y-rhs.y, z-rhs.z};}\n
        VectorXYZ scale(double f) const {return {f*x, f*y, f*z};}\n
      "
  eic::VectorPolar:
    Members:
      - float r          // [mm] or [GeV]
      - float theta      // [rad, 0->pi]
      - float phi        // [rad, -pi->pi]
    ExtraCode:
      includes: "#include <cmath>\n#include<tuple>"
      declaration: "
        VectorPolar() : r{0}, theta{0}, phi{0} {}\n
        VectorPolar(double rr, double th, double ph) : r{static_cast<float>(rr)}, theta{static_cast<float>(th)}, phi{static_cast<float>(ph)} {}\n
        template<class VectorXYZType> VectorPolar(const VectorXYZType& v) : VectorPolar(v.r(), v.theta(), v.phi()) {}\n
        float mag() const {return r;}\n
        float x() const {return r * cos(phi) * sin(theta);}\n
        float y() const {return r * sin(phi) * sin(theta);}\n
        float z() const {return r * cos(theta);}\n
        float eta() const {return -log(tan(0.5*theta));}\n
        operator std::tuple<float, float, float>() {return {r, theta, phi};}\n
      "

  eic::VectorXYZT:
    Members:
      - double x        // [mm] or [GeV]
      - double y        //
      - double z        //
      - double t        // [ns] or [GeV]
    ExtraCode:
      includes: "#include <cmath>\n#include <tuple>"
      declaration: "
        VectorXYZT() : x{0}, y{0}, z{0}, t{0} {}\n
        VectorXYZT(double xx, double yy, double zz, double tt) : x{xx}, y{yy}, z{zz}, t{tt} {}\n
        double& operator[](unsigned i) {return *(&x + i);}\n
        const double& operator[](unsigned i) const {return *(&x + i);}\n
        double mag() const {return std::hypot(x, y, z);}\n
        double r() const {return mag();}\n
        double theta() const {return acos(z/mag());}\n
        double phi() const {return atan2(y,x);}\n
        double eta() const {return -log(tan(0.5*theta()));}
        double energy() const {return t;}\n
        double mass() const {return sqrt(t*t - x*x - y*y - z*z);}\n
        operator std::tuple<double, double, double, double>() {return {x, y, z, t};}\n
        double dot(const VectorXYZT& rhs) const {return t*rhs.t - x*rhs.x - y*rhs.y - z*rhs.z;}\n
        VectorXYZT add(const VectorXYZT& rhs) const {return {x+rhs.x, y+rhs.y, z+rhs.z, t+rhs.t};}\n
        VectorXYZT subtract(const VectorXYZT& rhs) const {return {x-rhs.x, y-rhs.y, z-rhs.z, t-rhs.t};}\n
        VectorXYZT scale(double f) const {return {f*x, f*y, f*z, f*t};}\n
      "

  eic::CovDiagXYZ:
    Members:
      - float xx
      - float yy
      - float zz
    ExtraCode:
      declaration: "
        CovDiagXYZ() : xx{0}, yy{0}, zz{0} {}\n
        CovDiagXYZ(double x, double y, double z) : xx{static_cast<float>(x)}, yy{static_cast<float>(y)}, zz{static_cast<float>(z)} {}\n
        float operator()(unsigned i, unsigned j) const {return (i == j) ? *(&xx + i) : 0.;}\n
        "

  eic::CovDiagXYZT:
    Members:
      - float xx
      - float yy
      - float zz
      - float tt
    ExtraCode:
      declaration: "
        CovDiagXYZT() : xx{0}, yy{0}, zz{0}, tt{0} {}\n
        CovDiagXYZT(float x, float y, float z, float t) : xx{x}, yy{y}, zz{z}, tt{t} {}\n
        float operator()(unsigned i, unsigned j) const {return (i == j) ? *(&xx + i) : 0.;}\n
        "

  eic::CovXYZ:
    Members:
      - float xx
      - float yy
      - float zz
      - float xy
      - float xz
      - float yz
    ExtraCode:
      declaration: "
        CovXYZ() : xx{0}, yy{0}, zz{0}, xy{0}, xz{0}, yz{0} {}\n
        CovXYZ(double vx, double vy, double vz, double vxy, double vxz, double vyz)\n
          : xx{static_cast<float>(vx)}, yy{static_cast<float>(vy)}, zz{static_cast<float>(vz)},\n
            xy{static_cast<float>(vxy)}, xz{static_cast<float>(vxz)}, yz{static_cast<float>(vyz)} {}\n
        float operator()(unsigned i, unsigned j) const {\n
          // diagonal\n
          if (i == j) {\n
            return *(&xx + i);\n
          }\n
          // off-diagonal\n
          // we have as options (0, 1), (0, 2) and (1, 2) (and mirrored)\n
          // note that, starting from xy, we find the correct element at (i+j-1)\n
          return *(&xy + i + j - 1);\n
        }\n
      "

datatypes :

  eic::EventInfo:
    Description : "Event Info"
    Author : "W.Armstrong"
    Members :
      - long long run      // Run number.
      - long long number   // Event number.
      - long long genID    // Generator ID (TBD).
      - long long procID   // Processes ID (TBD).
      - long long type     // event type ID (TBD).

  eic::Particle :
    Description : "Basic Particle used for reconstructed and generated particles"
    Author : "W.Armstrong"
    Members :
      - eic::VectorXYZ     p       // Four momentum.
      - eic::VectorXYZT    v       // vertex.
      - double             mass    // mass
      - long long          pid     // Particle type identification code
      - long long          status  // Status code

  eic::RawTrackerHit:
    Description : "Raw (digitized) tracker hit"
    Author : "W.Armstrong"
    Members:
      - long long cellID // The detector specific (geometrical) cell id.
      - int time         // tdc value.
      - int charge       // adc value

  eic::TrackerHit:
    Description : "Tracker hit (reconstructed from Raw)"
    Author : "W.Armstrong"
    Members :
      - long long            cellID    // The detector specific (geometrical) cell id.
      - float                time      // The time of the hit.
      - float                EDep      // EDep
      - float                EDepError // error on EDep
      - eic::VectorXYZ       position  // position
      - eic::CovDiagXYZ covMatrix // covMatrix

  eic::ReconstructedParticle:
    Description: "EIC Reconstructed Particle"
    Author : "W.Armstrong"
    Members:
      - long long      pid            // PID of reconstructed particle.
      - double         energy         // Energy of the reconstructed particle.
      - eic::VectorXYZ p              // three momentum.
      - double         charge         // The particle's charge
      - double         mass           // The mass of the particle in [GeV]

  eic::TrackParameters:
    Description: "ACTS Track parameters"
    Author : "W.Armstrong"
    Members:
      - double loc0        // loc0      
      - double loc1        // loc1      
      - double phi         // phi       
      - double theta       // theta     
      - double qOverP      // qOverP    
      - double time        // time      
      - double err_loc0    // err_loc0  
      - double err_loc1    // err_loc1  
      - double err_phi     // err_phi   
      - double err_theta   // err_theta 
      - double err_qOverP  // err_qOverP
      - double err_time    // err_time  

  eic::Vertex:
      Description: "EIC vertex"
      Author : "W.Armstrong"
      Members:
        - int             primary     // Whether it is the primary vertex of the event
        - float           chi2        // Chi squared of the vertex fit.
        - float           probability // Probability of the vertex fit
        - eic::VectorXYZT position    // postion and time of vertex.

  eic::RawPMTHit:
    Description: "EIC Raw PMT hit"
    Author: "C. Peng"
    Members:
      - long long cellID     // The detector specific (geometrical) cell id.
      - unsigned  amplitude  // PMT signal amplitude
      - unsigned  timeStamp  // PMT signal time

  eic::PMTHit:
    Description: "EIC PMT hit"
    Author: "C. Peng"
    Members:
      - long long cellID          // The detector specific (geometrical) cell id.
      - float npe                 // estimated number of photo-electrons
      - float time                // time
      - eic::VectorXYZ position   // PMT hit position
      - eic::VectorXYZ local // The local position of the hit in detector coordinates.

  eic::RIChCluster:
    Description: "EIC RICh Cluster"
    Author: "C. Peng"
    Members:
      - eic::VectorXYZ position // Global position of the cluster.
      - float theta             // opening angle of the ring
      - float radius            // radius of the best fit ring
      - float radiusError       // estimated error from the fit
      - float npe               // number of photo-electrons

  ## ==========================================================================
  ## Calorimetry
  ## ==========================================================================
  eic::RawCalorimeterHit:
    Description: "Raw (digitized) calorimeter hit"
    Author: "W. Armstrong, S. Joosten"
    Members:
      - int64_t           cellID            // The detector specific (geometrical) cell id.
      - int64_t           amplitude         // The amplitude of the hit in ADC counts.
      - int64_t           time              // Timing in TDC
      - eic::Index        ID                // unique ID for this hit

  eic::CalorimeterHit:
    Description: "Calorimeter hit"
    Author: "W. Armstrong, S. Joosten"
    Members:
      - int64_t           cellID            // The detector specific (geometrical) cell id.
      - eic::Index        ID                // unique ID for this hit
      - int32_t           layer             // layer for this hit
      - int32_t           sector            // sector for this hit
      - int32_t           type              // The type of the hit.
      - float             energy            // The energy for this hit in [GeV].
      - float             energyError       // Error on energy [GeV].
      - float             time              // The time of the hit in [ns].
      - eic::VectorXYZ    position          // The global position of the hit in world coordinates [mm].
      - eic::VectorXYZ    local             // The local position of the hit in detector coordinates [mm].
      - eic::VectorXYZ    dimension         // The dimension information of the cell [mm].

  ## ==========================================================================
  ## Clustering
  ## ==========================================================================
  
  eic::ProtoCluster:
    Description: "Relational info linking hits to their associated cluster"
    Author: "S. Joosten"
    Members:
      - eic::Index        hitID             // Hit ID
      - eic::Index        clusterID         // ID of the cluster associated with this hit (-1 if none)
      - float             weight            // How much of this hit belongs to the cluster? [0->1]

  eic::Cluster:
    Description: "EIC cluster"
    Author: "W. Armstrong, S. Joosten, C.Peng"
    Members:
      - eic::Index        ID                // unique ID for this cluster
      - int32_t           type              // Cluster type
      - float             energy            // Reconstructed energy of the cluster [GeV].
      - float             energyError       // Error on the cluster energy [GeV]
      - float             time              // [ns]
      - uint32_t          nhits             // Number of hits in the cluster.
      - eic::VectorXYZ    position          // Global position of the cluster [mm].
      - eic::CovXYZ       positionError     // Covariance matrix of the position (6 Parameters).
      - float             radius            // shower radius [mm]
      - float             skewness          // shower skewness [unitless]

  eic::Cluster2DInfo:
    Description: "Additional info for 3D clusters" 
    Author: "S. Joosten"
    Members:
      - eic::Index        clusterID         // Primary cluster ID
      - eic::VectorPolar  polar             // Cluster position polar information
      - float             eta               // Cluster pseudorapidity

  eic::Cluster3DInfo:
    Description: "Additional info for 3D clusters" 
    Author: "S. Joosten"
    Members:
      - eic::Index        clusterID         // Primary cluster ID
      - eic::VectorPolar  polar             // Cluster position polar information
      - float             eta               // Cluster pseudorapidity
      - eic::Direction    direction         // Intrinsic direction of the cluster at the central position [rad, 0->pi and -pi->pi]

  eic::ClusterLayer:
    Description: "2D Cluster in a single layer for a multi-layer detector"
    Author: "S. Joosten, C. Peng"
    Members:
      - eic::Index        ID                // unique layer ID
      - eic::Index        clusterID         // associated full 3D cluster, -1 if none
      - int32_t           layer             // layer number for this cluster layer
      - uint32_t          nhits             // Number of hits
      - int32_t           type              // Cluster type
      - float             energy            // Energy in this cluster layer [GeV]
      - float             energyError       // Error on energy [GeV]
      - float             radius            // Shower radius [mm]
      - float             skewness          // Skewness of hits distribution
      - eic::VectorXYZ    position          // Global center position. [mm]
